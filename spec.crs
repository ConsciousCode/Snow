{doc "Snow Spec" [
	{center [
		{heading Snow}
		{heading 3 [A Proposition for a More Concise/Expressive Data Representation]}
		{bold {color darkgrey [(By: Robert McDaniels)]}}
	]}
	{heading [Table of Contents]}
	{list by:*
		[{link #1 [1 Introduction]}{list by:o
			{link #1.1 [1.1 Foreword]}
			{link #1.2 [1.2 Purpose]}
			{link #1.3 [1.3 Definitions]}
			{link #1.4 [1.4 Why "Snow"?]}
		}]
		[{link #2 [2 Specifics]}{list by:o
			{link #2.1 [2.1 Values]}
			{link #2.2 [2.2 Tags]}
			{link #2.3 [2.3 Sections]}
		}]
		[{link #3 [3 Style Guide]}{list by:o
			{link #3.1 [3.1 Purpose]}
			{link #3.2 [3.2 Tags and Attributes]}
			{link #3.3 [3.3 Tagspace Design]}
			[{link #3.4 [3.4 Methods for Common Tasks]}{list by:square
				{link #3.4.1 [3.4.1 Support for Number/Boolean/Null/...]}
				{link #3.4.2 [3.4.2 Ordered Aggregate Type]}
				{link #3.4.3 [3.4.3 Associative Array]}
				{link #3.4.4 [3.4.4 Comments]}
			}]
		}]
		[{link #4 [4 History]}{list by:o
			{link #4.1 [4.1 Conception]}
			{link #4.2 [4.2 Implementation]}
			{link #4.3 [4.3 Cirrus]}
		}]
	}{line}
	{heading id:1 1 [1 Introduction]}
	{heading id:1.1 2 [1.1 Foreword]}
	{indent [
		Snow is designed with simplicity, flexibility, and conciseness in mind. It was inspired by my own frustrations with HTML formatting quirks and the lack of representation that JSON offers. It draws upon the syntaxes of XML, JSON, and Smarty to create something that is more than the sum of its parts. I hope it will become more useful with the more exposure it gets.
	]}{line}
	{heading id:1.2 2 [1.2 Purpose]}
	{indent [
		Snow is a hierarchical data representation taking inspiration from languages with similar goals like XML and JSON with the intention of fixing the mistakes made by them in their pioneering. The original purpose of Snow was to attempt to replace HTML as a more concise and intuitive layout structure, which was soon after generalized to allow for arbitrary data representation.
	]}{line}
	{indent [
		It shines most whenever a nontrivial data structure representation is required, though it can easily be used for simpler structures with no drawbacks. Where XML requires non trivial attribute data (such as dates or colors) to be represented as either a specialized string format or as a child tag, Snow allows attributes to contain tags. Where JSON is a sparse, highly concise data representation, it has no mechanisms for typesafe representations of more complex data types than aggregates and its small set of primitive types like Snow or XML do.
	]}{line}
	{heading id:1.3 2 [1.3 Definitions]}
	{list
		[{bold "Tagset:"} A set of tag definitions that define what the tags and their contained data represent.]
		[{bold "Document:"} The file/stream containing all of the data relevant to a Snow structure.]
		[{bold "Value:"} A tag, section, or text regardless of format.]
		[{bold "Tag:"} A named data format which may have attributes and contain more tags. The basic syntax of this kind of element is \{tagname <attributes>...}]
		[{bold "Empty Tag:"} A tag with no attributes.]
		[{bold "Child:"} A value that exists within the attributes of a tag that’s higher up in the hierarchy.]
		[{bold "Attribute:"} A named bit of data that may be assigned to a tag based on its definition. When appearing within a tag, they may either be unnamed and assigned based on position, or named using the format name:value. Attributes are separated by whitespace.]
		[{bold "Positional Attribute:"} Any attribute that has no associated name.]
		[{bold "Named Attribute:"} Any attribute associated with a name.]
		[{bold "Section:"} A designated section in the document in which unquoted text and tags may coexist unambiguously. This is designated using square brackets ([...\]). This is mostly intended for use as markup.]
		[{bold "Text:"} Any kind of text/string that appears outside of Snow’s basic syntax.]
		[{bold "Quoted Text:"} Text which exists within quotes to allow for the use of otherwise restricted characters.]
		[{bold "Unquoted Text:"} Text which follows stricter guidelines to allow it to not require quotes. This is useful for attribute names, which rarely contain restricted characters, but are unintuitive to require quotes.]
	}
	{heading id:1.4 2 [1.4 Why "Snow"?]}
	{indent [
		After going through two temporary (atrocious) working names, it was finally decided to go with the title of Snow. Snowflakes have a highly regular crystalline structure, are moderately fractal in nature (containing smaller layers of patterns), and can collect together into a heap (or document, as the case may be), all properties that I believe Snow possesses. The name was actually inspired by the naming of Cirrus based on the idea that Cirrus documents would exist "on the cloud". This led to trying to come up with a name which was related to clouds in some way, and eventually coming to Snow.
	]}{line}
	{heading id:2 1 [2 Specifics]}
	{heading id:2.1 2 [2.1 Values]}
	The values that an attribute may take on are as follows:
	{list by:*
		[Text (double/single quoted, or unquoted but restricted)
			{list by:o
				[Quoted strings may contain escaped characters (\\, \', \", \a, \b, \f, \r, \t, \v), as well as escaped hex/unicode values (\x??, \u????, \U????????) and Pythonic named unicode values (\N\{<unicode character name>})]
				[Any occurrence of a backslash that does not match one of the above patterns simply produces a backslash.]
				[If quoted text is preceded by r (e.g. r"..."), then no escapes other than those applicable to the quote type are processed (to clarify, r'What is \"bacon\"?' would produce a string containing backslashes).]
				[Newlines may appear in a quoted string and will always produce \n regardless of the newline format being used by the document.]
				[Unquoted text may contain any non-whitespace, non-control character that isn't an opening or closing bracket or brace ([\] \{}), single or double quote (' "), or a colon :]
			}
		]
		[Tag {list by:o
			[Tags define a rigid structure with attributes given a particular associated meaning based on the tagset.]
		}]
		[Section {list by:o
			[Sections define a loose, flowing structure mostly for the purposes of markup.]
		}]
	}
	{heading id:2.2 2 [2.2 Tags]}
	{indent [
		Tags are start with an open brace \{ and end with a close brace }. They may appear literally anywhere in the document except in quoted text. Tags may have a number of attributes, which may be separated by whitespace, though this is only necessary when to do otherwise would yield ambiguity (i.e. one unquoted text following another).
	]}{line}
	{indent [
		A tag definition defines a number of attributes, their possible values, and their default. When a tag occurs in a Snow document, the named attributes are loaded first, then any leftover positional attributes fill in the remaining attributes. Tag names are themselves the first positional attribute of a tag, and may be any value type (including tags and sections)
	]}{line}
	{indent [
		Tags may contain no attributes (other than their tag name), making them empty tags. This is useful for inserting atomic, attributeless elements like most uses of HTML's <br> tag, as well as representing an arbitrary data model’s singletons.
	]}{line}
	{indent [
		Tags may be handed any number of attributes no matter how many are defined in their tag definition (though the extras might be ignored). This is useful for implementing aggregate types or "global" attributes which are ignored if not specified.
	]}{line}
	{indent [
		If more than one attribute has the same name, their contents should be combined into a section. However, the elements should be treated as separate (individually indexable). This is intended to yield useful behavior for something that would otherwise be ignored.
	]}{line}
	{heading id:2.3 2 [2.3 Sections]}
	{indent [
		Sections begin with an open bracket [ and end with a close bracket \]. Within them, text and tags may be used together in any combination or order (sections have no meaning within a section unless they're in a tag). Open brackets [ and close braces } may be used unambiguously, but close brackets \] and open braces \{ must be escaped by prepending them with backslashes \. Any other instance of the backslash will simply yield a backslash.
	]}{line}
	{indent [
		Snow documents are actually a special form of section contained by the file itself. Because of this, documents don't require escaping the close brace \].
	]}{line}
	{indent [
		The content of a section will likely be, for formatting reasons, on multiple lines with a certain amount of indentation. A Snow parser should make no attempt to strip it of this whitespace, and should instead leave it up to the particular tagset to decide what to do with it.
	]}{line}
	{heading id:3 1 [3 Style Guide]}
	{heading id:3.1 2 [3.1 Purpose]}
	{indent [
		The purpose of this style guide is to act as a rough guideline for how to style Snow documents as well as provide suggestions for how to accomplish common tasks. It is by no means meant to be taken as an absolute. Feel free to deviate from this as much as you want, as long as it works for you.
	]}{line}
	{heading id:3.2 2 [3.2 Tags and Attributes]}
	{indent [
		Tags should have no space between the open brace \{ and the tag's name. If they contain a lot of attributes or content, their closing brace } should be on a line of its own with the same indentation as the opening brace. If there's only a few short attributes, the tag may all be on one line.
	]}{line}
	{indent [
		If the tag is multiline, each attribute (positional or named) should be on their own lines (or more than one if applicable). Multi-line sections should have their opening brace "[" on the same line as the previous attribute or the tag name, unless the section is a named attribute.
	]}{line}
	{indent [
		Optionally, a mix between single-lined and multi-lined can be used with an attribute or two if they're short. However, an attribute should only share a line with another if it's positional. Named attributes should either have no space between the name and value, or no space to the left and a space to the right (though whichever you choose should be consistent).
	]}{line}
	For example:{line}
	<insert example>{line}
	{heading id:3.3 2 [3.3 Tagset Design]}
	{indent [
		While the standard allows practically any character to appear in a name (as well as the aggregate data types), that doesn't mean just any should. Names should be succinct and to the point. Mnemonics and acronyms can be used if they’re obvious, though you should keep other people in mind when determining if it really is "obvious".
	]}{line}
	{indent [
		Usually you want to avoid names that start with numbers as some tools might not work well with them. This might not be an issue depending on what it's being used for, and you should always prioritize obviousness (for instance, a 3d tag would be much better than a dim3 tag).
	]}{line}
	{indent [
		When designing a tagset, you should also keep in mind the ordering of the attributes, as some attributes may feel more important and people will expect them to come earlier without the need for an attribute name. Thus, high-priority attributes should usually be first, followed by any content attributes, and finally, low-priority attributes that you expect to be assigned more rarely (using a named attribute).
	]}{line}
	{heading id:3.4 2 [3.4 Methods for Common Tasks]}
	{indent [
		Because of Snow's structure, some common tasks require slightly different thinking than usual. This is meant to be a basic list of some of the more obvious cases:
	]}{line}
	{heading id:3.4.1 3 [3.4.1 Support for Number/Boolean/Null/Etc Values]}
	{indent [
		According to the rest of the spec, the only fundamentally supported types are tags, sections, and text. However, this doesn't mean that what looks like first-class support for common types can't be supported.
	]}{line}
	{indent [
		If the tagset has distinct values for each attribute, one can simply use unquoted text to express the value, then handle it as though it were the intended type (e.g. temp:73.29 might be parsed as text, but it's trivial to check if the value is a number and convert it to a native number type, and most APIs should provide a few helper functions that do this for you). Alternatively, if types are mixed and ambiguous (like strings and booleans), you can opt to use Snow's tags to indicate type (such as repl:"text" vs repl:\{true} or repl:\{bool true} or repl:\{val true}).
	]}{line}
	{heading id:3.4.2 3 [3.4.2 Ordered Aggregate Type]}
	{indent [
		That is, something similar to JSON's list type. At first you might think you could use a section and parse out any extra whitespace, but a much easier way to approach it is to add a list tag to the tagset. The list tag wouldn't define any attributes, but would take an arbitrary number of them which are ordered accordingly. The tagset should define the tag as not allowing named attributes.
	]}{line}
	{heading id:3.4.3 3 [3.4.3 Associative Array]}
	{indent [
		A similar technique as above exists for an associative array. Define some tag, like dict, which has no attributes (though that's not strictly required for this, it reduces attribute pollution) and hand it an arbitrary number of named attributes. The tagset should define the tag as not allowing positional attributes.
	]}{line}
	{heading id:3.4.4 3 [3.4.4 Comments]}
	{indent [
		At first it may seem strange that a data representation that aims to improve upon the mistakes of others doesn’t have a defined comment system, but this is purposeful. Some time in the middle of the design phase, it was realized that it was possible for a tagset to define its own comment tag if tag building methods were allowed to return a null value to indicate that nothing should be added to the data. Thus, comments were no longer a special case outlier and could be defined like any other. While any tag may be ignored, the recommended style for a comment tag is something like \{! [ comment text goes here \]}.
	]}{line}
	{heading id:4 1 [4 History]}
	{indent [
		I'm no good at remembering things, so I figured I'd write this down before the early history of Snow was lost forever.
	]}{line}
	{heading id:4.1 2 [4.1 Conception]}
	{indent [
		Snow was originally conceived May 26, 2014 while designing a small feature to a website I maintain. I grew rather frustrated at how unintuitive the HTML/CSS styling was for this particular feature (the fix for which was using a nasty fixed-height, negative margin style), so to vent I started playing around with some ideas for what would be an ideal replacement for HTML. It started out as something similar to JSON, but with class object support (prepending a name to an object), but as I was thinking of how I would embed markup, I realized that that would be too ambiguous, so I moved the class name (soon after, tag name) inside. Around this time, I came up with the working title "CML" (Concise Markup Language) to have something to refer to, though I was somewhat dissatisfied with the name because it was neither particularly catchy, nor technically accurate.
	]}{line}
	{indent [
		Commas were also initially used to separate attributes, but after writing a quick example, I realized that I had completely forgotten all commas, and yet what was present was entirely unambiguous. Over the next 2-3 days, I tweaked the syntax somewhat, allowed for more and more flexible structures (starting with the allowance of tags or sections being used as names),  and started working with Psyonide and Moonlightning to help with organization and bounce ideas around about what should be implemented and how.
	]}{line}
	{heading id:4.2 2 [4.2 Implementation]}
	{indent [
		Work on the actual implementation first begun the same day I conceived Snow in Javascript, though that was quickly abandoned after writing out the spec and realizing that there were too many new features for the old (broken) code to be renovated. Work was instead moved to Python for rapid development after the syntax had taken on a more defined form. It was around this time that I replaced the CML name with CXD, Concise eXtensible Data (which I hated even more, but still used because unlike CML, it was technically accurate).
	]}{line}
	{indent [
		After a few hours of development, the first prototype parser for Snow was finished. It used a recursive descent parsing pattern with regex being used to lex individual tokens. More types were supported by default (numbers, boolean, null, and a distinction between unquoted and quoted text), but were later removed as it was realized these had no purpose being treated separately beyond some helper functions. The code was made into a github repository, more slight tweaks were made with the syntax (such as the ability to intermix positional and named attributes rather than forcing named attributes to be at the end), and work began on Cirrus, the first practical use of Snow.
	]}{line}
	{heading id:4.3 2 [4.3 Cirrus]}
	{indent [
		Since the prototype parser was operational and had already gone through some level of refinement, we decided on the 29th that it would be best to start work on Cirrus (then named "CXD HTML replacement tagspace", very catchy). A real name was needed so I could even save the code, and I randomly had the idea for a cloud-themed name (because it existed "on the cloud"). Cloud seemed too generic, so I went with the first cloud name I found that didn't have 4 syllables. From this I realized that CXD should have a cloud-related name, so after some brainstorming I came up with Snow.
	]}{line}
	{indent [
		I quickly built it up and implemented a few tags to test it (doc, bold, italic, and underline), using a visitor pattern to convert the Cirrus code to HTML. It worked, and more tags were added (link (HTML <a>) to test attributes, line to test empty tags, and image).
	]}{line}
]}